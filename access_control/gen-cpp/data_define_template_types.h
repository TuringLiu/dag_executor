/**
 * Autogenerated by Thrift Compiler (0.20.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef data_define_template_TYPES_H
#define data_define_template_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace recommend {

class UserData;

class ItemData;

class ThreadConfig;

class CircuitBreaker;

class ShortVideo;

class Ecommerce;

class Live;

class Engineering;

class Common;

class Context;

typedef struct _UserData__isset {
  _UserData__isset() : device_id(false) {}
  bool device_id :1;
} _UserData__isset;

class UserData : public virtual ::apache::thrift::TBase {
 public:

  UserData(const UserData&);
  UserData& operator=(const UserData&);
  UserData() noexcept
           : name(),
             age(0),
             sex(),
             location(),
             device_id(0) {
  }

  virtual ~UserData() noexcept;
  std::string name;
  int32_t age;
  std::string sex;
  std::string location;
  int32_t device_id;

  _UserData__isset __isset;

  void __set_name(const std::string& val);

  void __set_age(const int32_t val);

  void __set_sex(const std::string& val);

  void __set_location(const std::string& val);

  void __set_device_id(const int32_t val);

  bool operator == (const UserData & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(age == rhs.age))
      return false;
    if (!(sex == rhs.sex))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(device_id == rhs.device_id))
      return false;
    return true;
  }
  bool operator != (const UserData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UserData &a, UserData &b);

std::ostream& operator<<(std::ostream& out, const UserData& obj);


class ItemData : public virtual ::apache::thrift::TBase {
 public:

  ItemData(const ItemData&);
  ItemData& operator=(const ItemData&);
  ItemData() noexcept
           : item_id(),
             location() {
  }

  virtual ~ItemData() noexcept;
  std::string item_id;
  std::string location;
  std::map<std::string, std::vector<double> >  scores;
  std::vector<std::string>  tags;

  void __set_item_id(const std::string& val);

  void __set_location(const std::string& val);

  void __set_scores(const std::map<std::string, std::vector<double> > & val);

  void __set_tags(const std::vector<std::string> & val);

  bool operator == (const ItemData & rhs) const
  {
    if (!(item_id == rhs.item_id))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(scores == rhs.scores))
      return false;
    if (!(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const ItemData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemData &a, ItemData &b);

std::ostream& operator<<(std::ostream& out, const ItemData& obj);


class ThreadConfig : public virtual ::apache::thrift::TBase {
 public:

  ThreadConfig(const ThreadConfig&) noexcept;
  ThreadConfig& operator=(const ThreadConfig&) noexcept;
  ThreadConfig() noexcept
               : num(0),
                 task_num(0) {
  }

  virtual ~ThreadConfig() noexcept;
  int32_t num;
  int32_t task_num;

  void __set_num(const int32_t val);

  void __set_task_num(const int32_t val);

  bool operator == (const ThreadConfig & rhs) const
  {
    if (!(num == rhs.num))
      return false;
    if (!(task_num == rhs.task_num))
      return false;
    return true;
  }
  bool operator != (const ThreadConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThreadConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ThreadConfig &a, ThreadConfig &b);

std::ostream& operator<<(std::ostream& out, const ThreadConfig& obj);


class CircuitBreaker : public virtual ::apache::thrift::TBase {
 public:

  CircuitBreaker(const CircuitBreaker&);
  CircuitBreaker& operator=(const CircuitBreaker&);
  CircuitBreaker() noexcept {
  }

  virtual ~CircuitBreaker() noexcept;
  std::map<std::string, int32_t>  max_latency;
  std::map<std::string, std::string>  replace_node;

  void __set_max_latency(const std::map<std::string, int32_t> & val);

  void __set_replace_node(const std::map<std::string, std::string> & val);

  bool operator == (const CircuitBreaker & rhs) const
  {
    if (!(max_latency == rhs.max_latency))
      return false;
    if (!(replace_node == rhs.replace_node))
      return false;
    return true;
  }
  bool operator != (const CircuitBreaker &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CircuitBreaker & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CircuitBreaker &a, CircuitBreaker &b);

std::ostream& operator<<(std::ostream& out, const CircuitBreaker& obj);


class ShortVideo : public virtual ::apache::thrift::TBase {
 public:

  ShortVideo(const ShortVideo&);
  ShortVideo& operator=(const ShortVideo&);
  ShortVideo() noexcept {
  }

  virtual ~ShortVideo() noexcept;
  std::vector<int64_t>  list;
  std::vector<std::string>  model_list;
  std::map<std::string, std::vector<double> >  user_scores;
  std::map<int64_t, ItemData>  item_data;

  void __set_list(const std::vector<int64_t> & val);

  void __set_model_list(const std::vector<std::string> & val);

  void __set_user_scores(const std::map<std::string, std::vector<double> > & val);

  void __set_item_data(const std::map<int64_t, ItemData> & val);

  bool operator == (const ShortVideo & rhs) const
  {
    if (!(list == rhs.list))
      return false;
    if (!(model_list == rhs.model_list))
      return false;
    if (!(user_scores == rhs.user_scores))
      return false;
    if (!(item_data == rhs.item_data))
      return false;
    return true;
  }
  bool operator != (const ShortVideo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShortVideo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShortVideo &a, ShortVideo &b);

std::ostream& operator<<(std::ostream& out, const ShortVideo& obj);


class Ecommerce : public virtual ::apache::thrift::TBase {
 public:

  Ecommerce(const Ecommerce&);
  Ecommerce& operator=(const Ecommerce&);
  Ecommerce() noexcept {
  }

  virtual ~Ecommerce() noexcept;
  std::vector<int64_t>  list;
  std::vector<std::string>  model_list;
  std::map<std::string, std::vector<double> >  user_scores;
  std::map<int64_t, ItemData>  item_data;

  void __set_list(const std::vector<int64_t> & val);

  void __set_model_list(const std::vector<std::string> & val);

  void __set_user_scores(const std::map<std::string, std::vector<double> > & val);

  void __set_item_data(const std::map<int64_t, ItemData> & val);

  bool operator == (const Ecommerce & rhs) const
  {
    if (!(list == rhs.list))
      return false;
    if (!(model_list == rhs.model_list))
      return false;
    if (!(user_scores == rhs.user_scores))
      return false;
    if (!(item_data == rhs.item_data))
      return false;
    return true;
  }
  bool operator != (const Ecommerce &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Ecommerce & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Ecommerce &a, Ecommerce &b);

std::ostream& operator<<(std::ostream& out, const Ecommerce& obj);


class Live : public virtual ::apache::thrift::TBase {
 public:

  Live(const Live&);
  Live& operator=(const Live&);
  Live() noexcept {
  }

  virtual ~Live() noexcept;
  std::vector<int64_t>  list;
  std::vector<std::string>  model_list;
  std::map<std::string, std::vector<double> >  user_scores;
  std::map<int64_t, ItemData>  item_data;

  void __set_list(const std::vector<int64_t> & val);

  void __set_model_list(const std::vector<std::string> & val);

  void __set_user_scores(const std::map<std::string, std::vector<double> > & val);

  void __set_item_data(const std::map<int64_t, ItemData> & val);

  bool operator == (const Live & rhs) const
  {
    if (!(list == rhs.list))
      return false;
    if (!(model_list == rhs.model_list))
      return false;
    if (!(user_scores == rhs.user_scores))
      return false;
    if (!(item_data == rhs.item_data))
      return false;
    return true;
  }
  bool operator != (const Live &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Live & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Live &a, Live &b);

std::ostream& operator<<(std::ostream& out, const Live& obj);


class Engineering : public virtual ::apache::thrift::TBase {
 public:

  Engineering(const Engineering&);
  Engineering& operator=(const Engineering&);
  Engineering() noexcept {
  }

  virtual ~Engineering() noexcept;
  ThreadConfig thread_conf;
  CircuitBreaker breaker_conf;

  void __set_thread_conf(const ThreadConfig& val);

  void __set_breaker_conf(const CircuitBreaker& val);

  bool operator == (const Engineering & rhs) const
  {
    if (!(thread_conf == rhs.thread_conf))
      return false;
    if (!(breaker_conf == rhs.breaker_conf))
      return false;
    return true;
  }
  bool operator != (const Engineering &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Engineering & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Engineering &a, Engineering &b);

std::ostream& operator<<(std::ostream& out, const Engineering& obj);

typedef struct _Common__isset {
  _Common__isset() : user_data(false) {}
  bool user_data :1;
} _Common__isset;

class Common : public virtual ::apache::thrift::TBase {
 public:

  Common(const Common&);
  Common& operator=(const Common&);
  Common() noexcept {
  }

  virtual ~Common() noexcept;
  UserData user_data;

  _Common__isset __isset;

  void __set_user_data(const UserData& val);

  bool operator == (const Common & rhs) const
  {
    if (!(user_data == rhs.user_data))
      return false;
    return true;
  }
  bool operator != (const Common &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Common & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Common &a, Common &b);

std::ostream& operator<<(std::ostream& out, const Common& obj);

typedef struct _Context__isset {
  _Context__isset() : eng(false) {}
  bool eng :1;
} _Context__isset;

class Context : public virtual ::apache::thrift::TBase {
 public:

  Context(const Context&);
  Context& operator=(const Context&);
  Context() noexcept {
  }

  virtual ~Context() noexcept;
  Engineering eng;
  ShortVideo video;
  Ecommerce ecom;
  Live live;
  Common comm;

  _Context__isset __isset;

  void __set_eng(const Engineering& val);

  void __set_video(const ShortVideo& val);

  void __set_ecom(const Ecommerce& val);

  void __set_live(const Live& val);

  void __set_comm(const Common& val);

  bool operator == (const Context & rhs) const
  {
    if (__isset.eng != rhs.__isset.eng)
      return false;
    else if (__isset.eng && !(eng == rhs.eng))
      return false;
    if (!(video == rhs.video))
      return false;
    if (!(ecom == rhs.ecom))
      return false;
    if (!(live == rhs.live))
      return false;
    if (!(comm == rhs.comm))
      return false;
    return true;
  }
  bool operator != (const Context &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Context & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Context &a, Context &b);

std::ostream& operator<<(std::ostream& out, const Context& obj);

} // namespace

#endif
