/**
 * Autogenerated by Thrift Compiler (0.20.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data_define_template_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace recommend {


UserData::~UserData() noexcept {
}


void UserData::__set_name(const std::string& val) {
  this->name = val;
}

void UserData::__set_age(const int32_t val) {
  this->age = val;
}

void UserData::__set_sex(const std::string& val) {
  this->sex = val;
}

void UserData::__set_location(const std::string& val) {
  this->location = val;
}

void UserData::__set_device_id(const int32_t val) {
  this->device_id = val;
}
std::ostream& operator<<(std::ostream& out, const UserData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UserData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_age = false;
  bool isset_sex = false;
  bool isset_location = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->age);
          isset_age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sex);
          isset_sex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->device_id);
          this->__isset.device_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_age)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserData");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("device_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->device_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserData &a, UserData &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.age, b.age);
  swap(a.sex, b.sex);
  swap(a.location, b.location);
  swap(a.device_id, b.device_id);
  swap(a.__isset, b.__isset);
}

UserData::UserData(const UserData& other0) {
  name = other0.name;
  age = other0.age;
  sex = other0.sex;
  location = other0.location;
  device_id = other0.device_id;
  __isset = other0.__isset;
}
UserData& UserData::operator=(const UserData& other1) {
  name = other1.name;
  age = other1.age;
  sex = other1.sex;
  location = other1.location;
  device_id = other1.device_id;
  __isset = other1.__isset;
  return *this;
}
void UserData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserData(";
  out << "name=" << to_string(name);
  out << ", " << "age=" << to_string(age);
  out << ", " << "sex=" << to_string(sex);
  out << ", " << "location=" << to_string(location);
  out << ", " << "device_id=" << to_string(device_id);
  out << ")";
}


ItemData::~ItemData() noexcept {
}


void ItemData::__set_item_id(const std::string& val) {
  this->item_id = val;
}

void ItemData::__set_location(const std::string& val) {
  this->location = val;
}

void ItemData::__set_scores(const std::map<std::string, std::vector<double> > & val) {
  this->scores = val;
}

void ItemData::__set_tags(const std::vector<std::string> & val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const ItemData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ItemData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_item_id = false;
  bool isset_location = false;
  bool isset_scores = false;
  bool isset_tags = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->item_id);
          isset_item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->scores.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _ktype3;
            ::apache::thrift::protocol::TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _key7;
              xfer += iprot->readString(_key7);
              std::vector<double> & _val8 = this->scores[_key7];
              {
                _val8.clear();
                uint32_t _size9;
                ::apache::thrift::protocol::TType _etype12;
                xfer += iprot->readListBegin(_etype12, _size9);
                _val8.resize(_size9);
                uint32_t _i13;
                for (_i13 = 0; _i13 < _size9; ++_i13)
                {
                  xfer += iprot->readDouble(_val8[_i13]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_scores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tags.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->tags.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readString(this->tags[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_item_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scores)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ItemData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemData");

  xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->item_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scores", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->scores.size()));
    std::map<std::string, std::vector<double> > ::const_iterator _iter19;
    for (_iter19 = this->scores.begin(); _iter19 != this->scores.end(); ++_iter19)
    {
      xfer += oprot->writeString(_iter19->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(_iter19->second.size()));
        std::vector<double> ::const_iterator _iter20;
        for (_iter20 = _iter19->second.begin(); _iter20 != _iter19->second.end(); ++_iter20)
        {
          xfer += oprot->writeDouble((*_iter20));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->tags.begin(); _iter21 != this->tags.end(); ++_iter21)
    {
      xfer += oprot->writeString((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemData &a, ItemData &b) {
  using ::std::swap;
  swap(a.item_id, b.item_id);
  swap(a.location, b.location);
  swap(a.scores, b.scores);
  swap(a.tags, b.tags);
}

ItemData::ItemData(const ItemData& other22) {
  item_id = other22.item_id;
  location = other22.location;
  scores = other22.scores;
  tags = other22.tags;
}
ItemData& ItemData::operator=(const ItemData& other23) {
  item_id = other23.item_id;
  location = other23.location;
  scores = other23.scores;
  tags = other23.tags;
  return *this;
}
void ItemData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemData(";
  out << "item_id=" << to_string(item_id);
  out << ", " << "location=" << to_string(location);
  out << ", " << "scores=" << to_string(scores);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


ThreadConfig::~ThreadConfig() noexcept {
}


void ThreadConfig::__set_num(const int32_t val) {
  this->num = val;
}

void ThreadConfig::__set_task_num(const int32_t val) {
  this->task_num = val;
}
std::ostream& operator<<(std::ostream& out, const ThreadConfig& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThreadConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num = false;
  bool isset_task_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          isset_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_num);
          isset_task_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThreadConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThreadConfig");

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->task_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThreadConfig &a, ThreadConfig &b) {
  using ::std::swap;
  swap(a.num, b.num);
  swap(a.task_num, b.task_num);
}

ThreadConfig::ThreadConfig(const ThreadConfig& other24) noexcept {
  num = other24.num;
  task_num = other24.task_num;
}
ThreadConfig& ThreadConfig::operator=(const ThreadConfig& other25) noexcept {
  num = other25.num;
  task_num = other25.task_num;
  return *this;
}
void ThreadConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThreadConfig(";
  out << "num=" << to_string(num);
  out << ", " << "task_num=" << to_string(task_num);
  out << ")";
}


CircuitBreaker::~CircuitBreaker() noexcept {
}


void CircuitBreaker::__set_max_latency(const std::map<std::string, int32_t> & val) {
  this->max_latency = val;
}

void CircuitBreaker::__set_replace_node(const std::map<std::string, std::string> & val) {
  this->replace_node = val;
}
std::ostream& operator<<(std::ostream& out, const CircuitBreaker& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CircuitBreaker::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_max_latency = false;
  bool isset_replace_node = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->max_latency.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              std::string _key31;
              xfer += iprot->readString(_key31);
              int32_t& _val32 = this->max_latency[_key31];
              xfer += iprot->readI32(_val32);
            }
            xfer += iprot->readMapEnd();
          }
          isset_max_latency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->replace_node.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _ktype34;
            ::apache::thrift::protocol::TType _vtype35;
            xfer += iprot->readMapBegin(_ktype34, _vtype35, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _key38;
              xfer += iprot->readString(_key38);
              std::string& _val39 = this->replace_node[_key38];
              xfer += iprot->readString(_val39);
            }
            xfer += iprot->readMapEnd();
          }
          isset_replace_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_max_latency)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_replace_node)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CircuitBreaker::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CircuitBreaker");

  xfer += oprot->writeFieldBegin("max_latency", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->max_latency.size()));
    std::map<std::string, int32_t> ::const_iterator _iter40;
    for (_iter40 = this->max_latency.begin(); _iter40 != this->max_latency.end(); ++_iter40)
    {
      xfer += oprot->writeString(_iter40->first);
      xfer += oprot->writeI32(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replace_node", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->replace_node.size()));
    std::map<std::string, std::string> ::const_iterator _iter41;
    for (_iter41 = this->replace_node.begin(); _iter41 != this->replace_node.end(); ++_iter41)
    {
      xfer += oprot->writeString(_iter41->first);
      xfer += oprot->writeString(_iter41->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CircuitBreaker &a, CircuitBreaker &b) {
  using ::std::swap;
  swap(a.max_latency, b.max_latency);
  swap(a.replace_node, b.replace_node);
}

CircuitBreaker::CircuitBreaker(const CircuitBreaker& other42) {
  max_latency = other42.max_latency;
  replace_node = other42.replace_node;
}
CircuitBreaker& CircuitBreaker::operator=(const CircuitBreaker& other43) {
  max_latency = other43.max_latency;
  replace_node = other43.replace_node;
  return *this;
}
void CircuitBreaker::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CircuitBreaker(";
  out << "max_latency=" << to_string(max_latency);
  out << ", " << "replace_node=" << to_string(replace_node);
  out << ")";
}


ShortVideo::~ShortVideo() noexcept {
}


void ShortVideo::__set_list(const std::vector<int64_t> & val) {
  this->list = val;
}

void ShortVideo::__set_model_list(const std::vector<std::string> & val) {
  this->model_list = val;
}

void ShortVideo::__set_user_scores(const std::map<std::string, std::vector<double> > & val) {
  this->user_scores = val;
}

void ShortVideo::__set_item_data(const std::map<int64_t, ItemData> & val) {
  this->item_data = val;
}
std::ostream& operator<<(std::ostream& out, const ShortVideo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShortVideo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_list = false;
  bool isset_model_list = false;
  bool isset_user_scores = false;
  bool isset_item_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->list.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readI64(this->list[_i48]);
            }
            xfer += iprot->readListEnd();
          }
          isset_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->model_list.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->model_list.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += iprot->readString(this->model_list[_i53]);
            }
            xfer += iprot->readListEnd();
          }
          isset_model_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->user_scores.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _ktype55;
            ::apache::thrift::protocol::TType _vtype56;
            xfer += iprot->readMapBegin(_ktype55, _vtype56, _size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              std::string _key59;
              xfer += iprot->readString(_key59);
              std::vector<double> & _val60 = this->user_scores[_key59];
              {
                _val60.clear();
                uint32_t _size61;
                ::apache::thrift::protocol::TType _etype64;
                xfer += iprot->readListBegin(_etype64, _size61);
                _val60.resize(_size61);
                uint32_t _i65;
                for (_i65 = 0; _i65 < _size61; ++_i65)
                {
                  xfer += iprot->readDouble(_val60[_i65]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_user_scores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->item_data.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              int64_t _key71;
              xfer += iprot->readI64(_key71);
              ItemData& _val72 = this->item_data[_key71];
              xfer += _val72.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_item_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_model_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user_scores)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_item_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShortVideo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShortVideo");

  xfer += oprot->writeFieldBegin("list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->list.size()));
    std::vector<int64_t> ::const_iterator _iter73;
    for (_iter73 = this->list.begin(); _iter73 != this->list.end(); ++_iter73)
    {
      xfer += oprot->writeI64((*_iter73));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->model_list.size()));
    std::vector<std::string> ::const_iterator _iter74;
    for (_iter74 = this->model_list.begin(); _iter74 != this->model_list.end(); ++_iter74)
    {
      xfer += oprot->writeString((*_iter74));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_scores", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->user_scores.size()));
    std::map<std::string, std::vector<double> > ::const_iterator _iter75;
    for (_iter75 = this->user_scores.begin(); _iter75 != this->user_scores.end(); ++_iter75)
    {
      xfer += oprot->writeString(_iter75->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(_iter75->second.size()));
        std::vector<double> ::const_iterator _iter76;
        for (_iter76 = _iter75->second.begin(); _iter76 != _iter75->second.end(); ++_iter76)
        {
          xfer += oprot->writeDouble((*_iter76));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_data", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->item_data.size()));
    std::map<int64_t, ItemData> ::const_iterator _iter77;
    for (_iter77 = this->item_data.begin(); _iter77 != this->item_data.end(); ++_iter77)
    {
      xfer += oprot->writeI64(_iter77->first);
      xfer += _iter77->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShortVideo &a, ShortVideo &b) {
  using ::std::swap;
  swap(a.list, b.list);
  swap(a.model_list, b.model_list);
  swap(a.user_scores, b.user_scores);
  swap(a.item_data, b.item_data);
}

ShortVideo::ShortVideo(const ShortVideo& other78) {
  list = other78.list;
  model_list = other78.model_list;
  user_scores = other78.user_scores;
  item_data = other78.item_data;
}
ShortVideo& ShortVideo::operator=(const ShortVideo& other79) {
  list = other79.list;
  model_list = other79.model_list;
  user_scores = other79.user_scores;
  item_data = other79.item_data;
  return *this;
}
void ShortVideo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShortVideo(";
  out << "list=" << to_string(list);
  out << ", " << "model_list=" << to_string(model_list);
  out << ", " << "user_scores=" << to_string(user_scores);
  out << ", " << "item_data=" << to_string(item_data);
  out << ")";
}


Ecommerce::~Ecommerce() noexcept {
}


void Ecommerce::__set_list(const std::vector<int64_t> & val) {
  this->list = val;
}

void Ecommerce::__set_model_list(const std::vector<std::string> & val) {
  this->model_list = val;
}

void Ecommerce::__set_user_scores(const std::map<std::string, std::vector<double> > & val) {
  this->user_scores = val;
}

void Ecommerce::__set_item_data(const std::map<int64_t, ItemData> & val) {
  this->item_data = val;
}
std::ostream& operator<<(std::ostream& out, const Ecommerce& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Ecommerce::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_list = false;
  bool isset_model_list = false;
  bool isset_user_scores = false;
  bool isset_item_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->list.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += iprot->readI64(this->list[_i84]);
            }
            xfer += iprot->readListEnd();
          }
          isset_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->model_list.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->model_list.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += iprot->readString(this->model_list[_i89]);
            }
            xfer += iprot->readListEnd();
          }
          isset_model_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->user_scores.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _ktype91;
            ::apache::thrift::protocol::TType _vtype92;
            xfer += iprot->readMapBegin(_ktype91, _vtype92, _size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              std::string _key95;
              xfer += iprot->readString(_key95);
              std::vector<double> & _val96 = this->user_scores[_key95];
              {
                _val96.clear();
                uint32_t _size97;
                ::apache::thrift::protocol::TType _etype100;
                xfer += iprot->readListBegin(_etype100, _size97);
                _val96.resize(_size97);
                uint32_t _i101;
                for (_i101 = 0; _i101 < _size97; ++_i101)
                {
                  xfer += iprot->readDouble(_val96[_i101]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_user_scores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->item_data.clear();
            uint32_t _size102;
            ::apache::thrift::protocol::TType _ktype103;
            ::apache::thrift::protocol::TType _vtype104;
            xfer += iprot->readMapBegin(_ktype103, _vtype104, _size102);
            uint32_t _i106;
            for (_i106 = 0; _i106 < _size102; ++_i106)
            {
              int64_t _key107;
              xfer += iprot->readI64(_key107);
              ItemData& _val108 = this->item_data[_key107];
              xfer += _val108.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_item_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_model_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user_scores)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_item_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Ecommerce::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Ecommerce");

  xfer += oprot->writeFieldBegin("list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->list.size()));
    std::vector<int64_t> ::const_iterator _iter109;
    for (_iter109 = this->list.begin(); _iter109 != this->list.end(); ++_iter109)
    {
      xfer += oprot->writeI64((*_iter109));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->model_list.size()));
    std::vector<std::string> ::const_iterator _iter110;
    for (_iter110 = this->model_list.begin(); _iter110 != this->model_list.end(); ++_iter110)
    {
      xfer += oprot->writeString((*_iter110));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_scores", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->user_scores.size()));
    std::map<std::string, std::vector<double> > ::const_iterator _iter111;
    for (_iter111 = this->user_scores.begin(); _iter111 != this->user_scores.end(); ++_iter111)
    {
      xfer += oprot->writeString(_iter111->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(_iter111->second.size()));
        std::vector<double> ::const_iterator _iter112;
        for (_iter112 = _iter111->second.begin(); _iter112 != _iter111->second.end(); ++_iter112)
        {
          xfer += oprot->writeDouble((*_iter112));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_data", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->item_data.size()));
    std::map<int64_t, ItemData> ::const_iterator _iter113;
    for (_iter113 = this->item_data.begin(); _iter113 != this->item_data.end(); ++_iter113)
    {
      xfer += oprot->writeI64(_iter113->first);
      xfer += _iter113->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Ecommerce &a, Ecommerce &b) {
  using ::std::swap;
  swap(a.list, b.list);
  swap(a.model_list, b.model_list);
  swap(a.user_scores, b.user_scores);
  swap(a.item_data, b.item_data);
}

Ecommerce::Ecommerce(const Ecommerce& other114) {
  list = other114.list;
  model_list = other114.model_list;
  user_scores = other114.user_scores;
  item_data = other114.item_data;
}
Ecommerce& Ecommerce::operator=(const Ecommerce& other115) {
  list = other115.list;
  model_list = other115.model_list;
  user_scores = other115.user_scores;
  item_data = other115.item_data;
  return *this;
}
void Ecommerce::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Ecommerce(";
  out << "list=" << to_string(list);
  out << ", " << "model_list=" << to_string(model_list);
  out << ", " << "user_scores=" << to_string(user_scores);
  out << ", " << "item_data=" << to_string(item_data);
  out << ")";
}


Live::~Live() noexcept {
}


void Live::__set_list(const std::vector<int64_t> & val) {
  this->list = val;
}

void Live::__set_model_list(const std::vector<std::string> & val) {
  this->model_list = val;
}

void Live::__set_user_scores(const std::map<std::string, std::vector<double> > & val) {
  this->user_scores = val;
}

void Live::__set_item_data(const std::map<int64_t, ItemData> & val) {
  this->item_data = val;
}
std::ostream& operator<<(std::ostream& out, const Live& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Live::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_list = false;
  bool isset_model_list = false;
  bool isset_user_scores = false;
  bool isset_item_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->list.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += iprot->readI64(this->list[_i120]);
            }
            xfer += iprot->readListEnd();
          }
          isset_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->model_list.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->model_list.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += iprot->readString(this->model_list[_i125]);
            }
            xfer += iprot->readListEnd();
          }
          isset_model_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->user_scores.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _ktype127;
            ::apache::thrift::protocol::TType _vtype128;
            xfer += iprot->readMapBegin(_ktype127, _vtype128, _size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              std::string _key131;
              xfer += iprot->readString(_key131);
              std::vector<double> & _val132 = this->user_scores[_key131];
              {
                _val132.clear();
                uint32_t _size133;
                ::apache::thrift::protocol::TType _etype136;
                xfer += iprot->readListBegin(_etype136, _size133);
                _val132.resize(_size133);
                uint32_t _i137;
                for (_i137 = 0; _i137 < _size133; ++_i137)
                {
                  xfer += iprot->readDouble(_val132[_i137]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_user_scores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->item_data.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _ktype139;
            ::apache::thrift::protocol::TType _vtype140;
            xfer += iprot->readMapBegin(_ktype139, _vtype140, _size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              int64_t _key143;
              xfer += iprot->readI64(_key143);
              ItemData& _val144 = this->item_data[_key143];
              xfer += _val144.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_item_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_model_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user_scores)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_item_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Live::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Live");

  xfer += oprot->writeFieldBegin("list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->list.size()));
    std::vector<int64_t> ::const_iterator _iter145;
    for (_iter145 = this->list.begin(); _iter145 != this->list.end(); ++_iter145)
    {
      xfer += oprot->writeI64((*_iter145));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->model_list.size()));
    std::vector<std::string> ::const_iterator _iter146;
    for (_iter146 = this->model_list.begin(); _iter146 != this->model_list.end(); ++_iter146)
    {
      xfer += oprot->writeString((*_iter146));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_scores", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->user_scores.size()));
    std::map<std::string, std::vector<double> > ::const_iterator _iter147;
    for (_iter147 = this->user_scores.begin(); _iter147 != this->user_scores.end(); ++_iter147)
    {
      xfer += oprot->writeString(_iter147->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(_iter147->second.size()));
        std::vector<double> ::const_iterator _iter148;
        for (_iter148 = _iter147->second.begin(); _iter148 != _iter147->second.end(); ++_iter148)
        {
          xfer += oprot->writeDouble((*_iter148));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_data", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->item_data.size()));
    std::map<int64_t, ItemData> ::const_iterator _iter149;
    for (_iter149 = this->item_data.begin(); _iter149 != this->item_data.end(); ++_iter149)
    {
      xfer += oprot->writeI64(_iter149->first);
      xfer += _iter149->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Live &a, Live &b) {
  using ::std::swap;
  swap(a.list, b.list);
  swap(a.model_list, b.model_list);
  swap(a.user_scores, b.user_scores);
  swap(a.item_data, b.item_data);
}

Live::Live(const Live& other150) {
  list = other150.list;
  model_list = other150.model_list;
  user_scores = other150.user_scores;
  item_data = other150.item_data;
}
Live& Live::operator=(const Live& other151) {
  list = other151.list;
  model_list = other151.model_list;
  user_scores = other151.user_scores;
  item_data = other151.item_data;
  return *this;
}
void Live::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Live(";
  out << "list=" << to_string(list);
  out << ", " << "model_list=" << to_string(model_list);
  out << ", " << "user_scores=" << to_string(user_scores);
  out << ", " << "item_data=" << to_string(item_data);
  out << ")";
}


Engineering::~Engineering() noexcept {
}


void Engineering::__set_thread_conf(const ThreadConfig& val) {
  this->thread_conf = val;
}

void Engineering::__set_breaker_conf(const CircuitBreaker& val) {
  this->breaker_conf = val;
}
std::ostream& operator<<(std::ostream& out, const Engineering& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Engineering::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_thread_conf = false;
  bool isset_breaker_conf = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thread_conf.read(iprot);
          isset_thread_conf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->breaker_conf.read(iprot);
          isset_breaker_conf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_thread_conf)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_breaker_conf)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Engineering::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Engineering");

  xfer += oprot->writeFieldBegin("thread_conf", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thread_conf.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("breaker_conf", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->breaker_conf.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Engineering &a, Engineering &b) {
  using ::std::swap;
  swap(a.thread_conf, b.thread_conf);
  swap(a.breaker_conf, b.breaker_conf);
}

Engineering::Engineering(const Engineering& other152) {
  thread_conf = other152.thread_conf;
  breaker_conf = other152.breaker_conf;
}
Engineering& Engineering::operator=(const Engineering& other153) {
  thread_conf = other153.thread_conf;
  breaker_conf = other153.breaker_conf;
  return *this;
}
void Engineering::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Engineering(";
  out << "thread_conf=" << to_string(thread_conf);
  out << ", " << "breaker_conf=" << to_string(breaker_conf);
  out << ")";
}


Common::~Common() noexcept {
}


void Common::__set_user_data(const UserData& val) {
  this->user_data = val;
}
std::ostream& operator<<(std::ostream& out, const Common& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Common::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user_data.read(iprot);
          this->__isset.user_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Common::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Common");

  xfer += oprot->writeFieldBegin("user_data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->user_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Common &a, Common &b) {
  using ::std::swap;
  swap(a.user_data, b.user_data);
  swap(a.__isset, b.__isset);
}

Common::Common(const Common& other154) {
  user_data = other154.user_data;
  __isset = other154.__isset;
}
Common& Common::operator=(const Common& other155) {
  user_data = other155.user_data;
  __isset = other155.__isset;
  return *this;
}
void Common::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Common(";
  out << "user_data=" << to_string(user_data);
  out << ")";
}


Context::~Context() noexcept {
}


void Context::__set_eng(const Engineering& val) {
  this->eng = val;
__isset.eng = true;
}

void Context::__set_video(const ShortVideo& val) {
  this->video = val;
}

void Context::__set_ecom(const Ecommerce& val) {
  this->ecom = val;
}

void Context::__set_live(const Live& val) {
  this->live = val;
}

void Context::__set_comm(const Common& val) {
  this->comm = val;
}
std::ostream& operator<<(std::ostream& out, const Context& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Context::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_video = false;
  bool isset_ecom = false;
  bool isset_live = false;
  bool isset_comm = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->eng.read(iprot);
          this->__isset.eng = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->video.read(iprot);
          isset_video = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ecom.read(iprot);
          isset_ecom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->live.read(iprot);
          isset_live = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->comm.read(iprot);
          isset_comm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_video)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ecom)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_live)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_comm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Context::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Context");

  if (this->__isset.eng) {
    xfer += oprot->writeFieldBegin("eng", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->eng.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("video", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->video.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ecom", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->ecom.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("live", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->live.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comm", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->comm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Context &a, Context &b) {
  using ::std::swap;
  swap(a.eng, b.eng);
  swap(a.video, b.video);
  swap(a.ecom, b.ecom);
  swap(a.live, b.live);
  swap(a.comm, b.comm);
  swap(a.__isset, b.__isset);
}

Context::Context(const Context& other156) {
  eng = other156.eng;
  video = other156.video;
  ecom = other156.ecom;
  live = other156.live;
  comm = other156.comm;
  __isset = other156.__isset;
}
Context& Context::operator=(const Context& other157) {
  eng = other157.eng;
  video = other157.video;
  ecom = other157.ecom;
  live = other157.live;
  comm = other157.comm;
  __isset = other157.__isset;
  return *this;
}
void Context::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Context(";
  out << "eng="; (__isset.eng ? (out << to_string(eng)) : (out << "<null>"));
  out << ", " << "video=" << to_string(video);
  out << ", " << "ecom=" << to_string(ecom);
  out << ", " << "live=" << to_string(live);
  out << ", " << "comm=" << to_string(comm);
  out << ")";
}

} // namespace
